#!/usr/bin/env node
/* eslint-disable no-restricted-syntax */

/**
 * CLI utility to generate TypeScript types from yass-orm model definitions.
 *
 * Usage:
 *   generate-types [options] <definition-files...>
 *
 * Options:
 *   --dry-run              Show what would be generated without writing files
 *   --verbose              Show generated content in dry-run mode
 *   --header-comment "..." Custom comment to add to the header of generated files
 *   --help                 Show this help message
 *
 * Examples:
 *   # Generate types for a single model
 *   generate-types path/to/models/defs/my-model.js
 *
 *   # Generate types for multiple models
 *   generate-types path/to/defs/*.js
 *
 *   # Dry run to preview output
 *   generate-types --dry-run --verbose path/to/defs/my-model.js
 *
 *   # Add custom header comment
 *   generate-types --header-comment "To regenerate: npm run generate-model-types" path/to/defs/*.js
 */

/* eslint-disable no-console */
const { generateTypesForFiles } = require('../lib/generate-types');

function showHelp() {
	console.log(`
Usage: generate-types [options] <definition-files...>

Generate TypeScript type definitions from yass-orm model definitions.

Options:
  --dry-run                     Show what would be generated without writing files
  --verbose                     Show generated content in dry-run mode
  --header-comment "..."        Custom comment to add to the header of generated files
  --workspace-roots "a,b,..."   Comma-separated workspace root names (e.g., "backend,shared")
                                When imports cross into these roots, workspace-relative paths
                                are used (e.g., 'backend/src/db/models/user') instead of
                                ugly relative paths (e.g., '../../../../../backend/...')
  --help                        Show this help message

Examples:
  # Generate types for a single model
  generate-types path/to/models/defs/my-model.js

  # Generate types for multiple models  
  generate-types path/to/defs/*.js

  # Dry run to preview output
  generate-types --dry-run --verbose path/to/defs/my-model.js

  # Use workspace-relative imports for backend and shared
  generate-types --workspace-roots "backend,shared" path/to/defs/*.js

Output:
  For each input file (e.g., my-model.js), a co-located .d.ts file
  is generated with:
  - Interface for instance properties
  - Type for static model methods
  - Default export type

  Output location is determined automatically:
  - TypeScript models (.ts): types go in defs/ folder
  - JavaScript models (.js): types go next to the model file
  
  Old type files in alternate locations are automatically cleaned up.
`);
}

async function main() {
	const args = process.argv.slice(2);

	// Parse options
	const options = {
		dryRun: false,
		verbose: false,
		headerComment: undefined,
		workspaceRoots: [],
	};

	const files = [];
	let i = 0;

	while (i < args.length) {
		const arg = args[i];

		if (arg === '--help' || arg === '-h') {
			showHelp();
			process.exit(0);
		} else if (arg === '--dry-run') {
			options.dryRun = true;
		} else if (arg === '--verbose') {
			options.verbose = true;
		} else if (arg === '--header-comment') {
			// Next argument is the comment value
			i++;
			if (i >= args.length) {
				console.error('Error: --header-comment requires a value');
				process.exit(1);
			}
			options.headerComment = args[i];
		} else if (arg === '--workspace-roots') {
			// Next argument is a comma-separated list of workspace root names
			i++;
			if (i >= args.length) {
				console.error('Error: --workspace-roots requires a value');
				process.exit(1);
			}
			options.workspaceRoots = args[i].split(',').map((r) => r.trim());
		} else if (arg.startsWith('-')) {
			console.error(`Unknown option: ${arg}`);
			showHelp();
			process.exit(1);
		} else {
			files.push(arg);
		}
		i++;
	}

	if (files.length === 0) {
		console.error('Error: No definition files specified.');
		showHelp();
		process.exit(1);
	}

	// Filter to only .js files and skip helper files
	const validFiles = files.filter((file) => {
		if (!file.endsWith('.js')) {
			console.warn(`Skipping non-JS file: ${file}`);
			return false;
		}
		if (file.includes('relativeModelLinkHelper')) {
			console.warn(`Skipping helper file: ${file}`);
			return false;
		}
		if (file.includes('/common/')) {
			console.warn(`Skipping common partial: ${file}`);
			return false;
		}
		return true;
	});

	if (validFiles.length === 0) {
		console.error('Error: No valid definition files to process.');
		process.exit(1);
	}

	console.log(`Processing ${validFiles.length} definition file(s)...`);

	try {
		const results = await generateTypesForFiles(validFiles, options);
		console.log(`\nSuccessfully generated ${results.length} type file(s).`);
	} catch (error) {
		console.error('Type generation failed:', error);
		process.exit(1);
	}
}

main().catch((error) => {
	console.error('Unexpected error:', error);
	process.exit(1);
});
