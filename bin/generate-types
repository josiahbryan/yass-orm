#!/usr/bin/env node
/* eslint-disable no-restricted-syntax */

/**
 * CLI utility to generate TypeScript types from yass-orm model definitions.
 *
 * Usage:
 *   generate-types [options] <definition-files...>
 *
 * Options:
 *   --dry-run              Show what would be generated without writing files
 *   --verbose              Show generated content in dry-run mode
 *   --header-comment "..." Custom comment to add to the header of generated files
 *   --help                 Show this help message
 *
 * Examples:
 *   # Generate types for a single model
 *   generate-types path/to/models/defs/my-model.js
 *
 *   # Generate types for multiple models
 *   generate-types path/to/defs/*.js
 *
 *   # Dry run to preview output
 *   generate-types --dry-run --verbose path/to/defs/my-model.js
 *
 *   # Add custom header comment
 *   generate-types --header-comment "To regenerate: npm run generate-model-types" path/to/defs/*.js
 */

/* eslint-disable no-console */
const {
	generateTypesForFiles,
	generateZodForFiles,
} = require('../lib/generate-types');

function showHelp() {
	console.log(`
Usage: generate-types [options] <definition-files...>

Generate TypeScript type definitions from yass-orm model definitions.

Options:
  --dry-run                     Show what would be generated without writing files
  --verbose                     Show generated content in dry-run mode
  --header-comment "..."        Custom comment to add to the header of generated files
  --workspace-roots "a,b,..."   Comma-separated workspace root names (e.g., "backend,shared")
                                When imports cross into these roots, workspace-relative paths
                                are used (e.g., 'backend/src/db/models/user') instead of
                                ugly relative paths (e.g., '../../../../../backend/...')
  --zod                         Also generate Zod validation schemas (.zod.ts files)
  --zod-only                    Only generate Zod schemas (skip .d.ts generation)
  --help                        Show this help message

Examples:
  # Generate types for a single model
  generate-types path/to/models/defs/my-model.js

  # Generate types for multiple models  
  generate-types path/to/defs/*.js

  # Generate both .d.ts and .zod.ts files
  generate-types --zod path/to/defs/*.js

  # Dry run to preview output
  generate-types --dry-run --verbose path/to/defs/my-model.js

  # Use workspace-relative imports for backend and shared
  generate-types --workspace-roots "backend,shared" path/to/defs/*.js

Output:
  For each input file (e.g., my-model.js), a co-located .d.ts file
  is generated with:
  - Interface for instance properties
  - Type for static model methods
  - Default export type

  With --zod, a .zod.ts file is also generated with:
  - Zod schemas for runtime validation
  - Input/Output types inferred from schemas
  - Partial schemas for update operations

  Output location is determined automatically:
  - TypeScript models (.ts): types go in defs/ folder
  - JavaScript models (.js): types go next to the model file
  - Zod schemas: always go in defs/ folder
  
  Old type files in alternate locations are automatically cleaned up.
`);
}

async function main() {
	const args = process.argv.slice(2);

	// Parse options
	const options = {
		dryRun: false,
		verbose: false,
		headerComment: undefined,
		workspaceRoots: [],
		generateZod: false,
		zodOnly: false,
	};

	const files = [];
	let i = 0;

	while (i < args.length) {
		const arg = args[i];

		if (arg === '--help' || arg === '-h') {
			showHelp();
			process.exit(0);
		} else if (arg === '--dry-run') {
			options.dryRun = true;
		} else if (arg === '--verbose') {
			options.verbose = true;
		} else if (arg === '--zod') {
			options.generateZod = true;
		} else if (arg === '--zod-only') {
			options.zodOnly = true;
			options.generateZod = true;
		} else if (arg === '--header-comment') {
			// Next argument is the comment value
			i++;
			if (i >= args.length) {
				console.error('Error: --header-comment requires a value');
				process.exit(1);
			}
			options.headerComment = args[i];
		} else if (arg === '--workspace-roots') {
			// Next argument is a comma-separated list of workspace root names
			i++;
			if (i >= args.length) {
				console.error('Error: --workspace-roots requires a value');
				process.exit(1);
			}
			options.workspaceRoots = args[i].split(',').map((r) => r.trim());
		} else if (arg.startsWith('-')) {
			console.error(`Unknown option: ${arg}`);
			showHelp();
			process.exit(1);
		} else {
			files.push(arg);
		}
		i++;
	}

	if (files.length === 0) {
		console.error('Error: No definition files specified.');
		showHelp();
		process.exit(1);
	}

	// Filter to only .js files and skip helper files
	const validFiles = files.filter((file) => {
		if (!file.endsWith('.js')) {
			console.warn(`Skipping non-JS file: ${file}`);
			return false;
		}
		if (file.includes('relativeModelLinkHelper')) {
			console.warn(`Skipping helper file: ${file}`);
			return false;
		}
		if (file.includes('/common/')) {
			console.warn(`Skipping common partial: ${file}`);
			return false;
		}
		return true;
	});

	if (validFiles.length === 0) {
		console.error('Error: No valid definition files to process.');
		process.exit(1);
	}

	console.log(`Processing ${validFiles.length} definition file(s)...`);

	try {
		let dtsCount = 0;
		let zodCount = 0;

		// Generate .d.ts files (unless --zod-only)
		if (!options.zodOnly) {
			const results = await generateTypesForFiles(validFiles, options);
			dtsCount = results.length;
		}

		// Generate .zod.ts files (if --zod or --zod-only)
		if (options.generateZod) {
			const zodResults = await generateZodForFiles(validFiles, options);
			zodCount = zodResults.length;
		}

		// Summary
		const parts = [];
		if (dtsCount > 0) parts.push(`${dtsCount} .d.ts`);
		if (zodCount > 0) parts.push(`${zodCount} .zod.ts`);
		console.log(`\nSuccessfully generated ${parts.join(' and ')} file(s).`);
	} catch (error) {
		console.error('Type generation failed:', error);
		process.exit(1);
	}
}

main().catch((error) => {
	console.error('Unexpected error:', error);
	process.exit(1);
});
