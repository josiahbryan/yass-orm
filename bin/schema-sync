#!/usr/bin/perl
use strict;

use Class::DBI;
use Data::Dumper;
use File::Basename;
use JSON qw/from_json/;
use Cwd qw(abs_path realpath);
use File::Basename;
use File::Spec;

# Find the config script even if schema-sync symlinked to node_modules/.bin
my $real_exec_path = dirname(abs_path($0));
my $abs_config = File::Spec->rel2abs(
	'../lib/config.js',
	$real_exec_path
);

# Find the convert script even if schema-sync symlinked to node_modules/.bin
my $abs_convert = $real_exec_path . '/convert-definition-to-schema.js';

my $config_json = `node $abs_config`;
my $config = from_json($config_json);

# DISABLE in production
our $ALLOW_DROP = 0;

our $DB_NAME  = $config->{schema};
our $DB_HOST  = $config->{host};
our $PASSWORD = $config->{password};

# $ALLOW_DROP = 1;

# die $PASSWORD."/".$TEST_MACHINE."|$TEST_MACHINE_MAC/".`hostname`;

# Setup connection to database
Class::DBI->connection("dbi:mysql::database=$DB_NAME;host=$DB_HOST;mysql_enable_utf8=1,mysql_multi_statements=1", 'root', $PASSWORD);

# Set options used by mysql_schema_update
our @mysql_schema_sql_debug_output;
our $mysql_schema_sql_dry_run = 0;

# Get DB handle for use below
my $dbh = Class::DBI->db_Main;

# Load list of model definitions from the command line
my @model_definitions = @ARGV;
if(!@model_definitions) {
	die "Usage: $0 <model definition files>";
}

# Add our match_ratio() function for use in custom-query-filter
upload_match_ratio_function($DB_HOST, $DB_NAME, 'root', $PASSWORD);

# For use below
sub attach_id_trigger {
	my $dbh   = shift; # for checking for trigger exists
	my $table = shift;

	# Creates a UUID for the id field
	upload_id_trigger($dbh, $DB_HOST, $DB_NAME, 'root', $PASSWORD, $table);
}

# Used to add the 'id' column automatically to tables below
# our @PriKeyAttrs = (
# 	'extra'	=> 'auto_increment',
# 	'type'	=> 'int(11)',
# 	'key'	=> 'PRI',
# 	readonly=> 1,
# 	auto	=> 1,
# );

our @PriKeyAttrs = (
	'extra'	   => 'auto_increment',
	'type'	   => 'int(11)',
	'key'	   => 'PRI',
	'readonly' => 1,
	'auto'	   => 1,
);


our @PriKeyUuuidAttrs = (
	'type'	=> 'char(36)',
	'key'	=> 'PRI',
	'null'	=> 0, # for sync
);

# Convert each definition to a schema using 'convert-definition-to-schema.js' in the current directory
foreach my $definition_file (@model_definitions) {

	# -common-fields is used internally by convert-definition, so exlude it if someone
	# just did a glob pattern, like definitions/*.js
	# Update to skip any files that start with a dash (-)
	next if $definition_file =~ /\/-[^\/]+\.js/;

	print "[$0] Processing: $definition_file ...\n";

	# Convert the definition file to a JSON object containing a field list in the format that
	# is compatible with mysql_schema_update()
	my $conversion_cmd = "node $abs_convert $definition_file";
	my $schema_json    = `$conversion_cmd`;
	my $schema         = from_json($schema_json);

	if($schema->{legacyExternalSchema}) {
		print "[$0] NOT syncing $definition_file to database, 'legacyExternalSchema' set to true\n";
		next;
	}

	# Add an 'id' field to the field list because Sequelize and Ember both expect an 'id' field,
	# but our definitions (intentionally) don't contain an id field
	my @fields = @{$schema->{fields} || []};
	my @id = grep { $_->{type} eq 'idKey' || $_->{type} eq 'uuidKey' } @fields;
	my $needs_id_trigger = 0;
	if(@id) {
		my $id = shift @id;
		my %attrs = $id->{type} eq 'uuidKey' ? @PriKeyUuuidAttrs : @PriKeyAttrs;

		$needs_id_trigger = 1 if $id->{type} eq 'uuidKey';

		foreach my $key (keys %attrs) {
			$id->{$key} = $attrs{$key};
		}

		# print STDERR "Found ID colum:" . Dumper($id, \%attrs);		
	} else {
		unshift @fields, { field => 'id', @PriKeyAttrs };
	}

	# Apply the actual update to the database (does nothing if the definiton and database match)
	mysql_schema_update($dbh, $DB_NAME, $schema->{table}, \@fields, $schema->{options});

	# Attach our UUID trigger
	if ($needs_id_trigger) {
		attach_id_trigger($dbh, $schema->{table});
	} else {
		# print STDERR "Table does not need ID trigger: $schema->{table}\n";
	}

	# one-time update as we convert these concepts
	# $dbh->do('alter table `'.$schema->{table}.'` drop deleted');
	#$dbh->do('update `'.$schema->{table}.'` set isDeleted=1 where deletedAt is not null') if !$TEST_MACHINE;
}

# our @PriKeyAttrs = (
# 	'extra'	=> 'auto_increment',
# 	'type'	=> 'int(11)',
# 	'key'	=> 'PRI',
# 	readonly=> 1,
# 	auto	=> 1,
# );
#
# mysql_schema_update($dbh,
# 	'ncs',
# 	'schema_sync_test',
# 	[
# 		{ field => 'id',	@PriKeyAttrs },
# 		{ field => 'name',	type => 'varchar' },
# 		{ field => 'age',	type => 'int', null => 0, default => 0 },
# 		{ field => 'notes',	type => 'text' },
# 	],
# 	{
# 		indexes	=> {
# 			foo	=> ['name','age']
# 		}
# 	}
# );
#

#####
# NOTE: 99% of the code for mysql_schema_update() copied from AppCore::DBI, and just slightly modified to run outside of AppCore

# Function: mysql_schema_update($dbh,$db,$table,$fields,$opts)
# Static function.
#
# Parameters:
# $dbh - Database connection handle
# $db - Database name in which to find the table
# $table - Name of the table to either CREATE or ALTER
# $fields - A arrayref, each row is a hashref
#           having the following keys: Field, Type, Null,Key,Default,Extra (see 'explain TABLE' in mysql)
# $opts - A hashref of options. Key/Values recognized:
#   'indexes'      - Hashref of index_name => [...field names...] to add as indexes to the database
#   'after_create' - EITHER an Anon sub (see below - dbh is first arg) OR an array ref of rows to insert
#                    Called AFTER create table is run
#   'after_alter' - Anon sub, called BEFORE the ALTER statements run.
#                    Sub will be given the $dbh as its first arg (dbh logged in)
#   'before_alter' - Anon sub, called AFTER the ALTER statemets run.
#                    Sub will be given the $dbh as its first arg (dbh logged in)

sub mysql_schema_update#($dbh, $db,$table,$fields,$opts)
{
	# Pull in our global variable for the dry_run flag
	my $dry_run = $mysql_schema_sql_dry_run;

	if(!@_)
	{
		die 'Usage: mysql_schema_update($db,$table,$fields,$opts) or mysql_schema_update($pkg,$class,...)';
	}

# 	die Dumper \@_;

	my ($dbh, $db,$table,$fields,$opts) = @_;
	local $_;

	my @sql;

	#print STDERR "Info: using db: '$db' for table '$table'\n";

	my $q_explain = $dbh->prepare('explain `'.$table.'`');
	my $old_fatal = $SIG{__DIE__};
	$SIG{__DIE__} = sub{return};
	eval '$q_explain->execute()';
	$SIG{__DIE__} = $old_fatal;
	#die $@ if $@ && $@ !~ /Table.*?doesn't exist/;
	#undef $@;
	#$table);
	#die $q_explain->rows;

	# NOTE: %fields will be used for comparing table to existing table AND
	# for checking for 'TEXT' columns when creating indexes - hence why this hash
	# was moved out of the first block, below.
	my %fields = map {$_->{field}=>$_} @$fields;

	# Assume table exists - compare
	if(!$@ && $q_explain->rows)
	{
		my %explain;
		my ($field,$type,$null,$key,$default,$extra,$x);
		# Perl's \(...) creates a ref for each var
		$q_explain->bind_columns(\($field,$type,$null,$key,$default,$extra));
		$explain{$field} = {field=>$field,type=>$type,null=>$null,key=>$key,default=>$default,extra=>$extra}
			while $q_explain->fetch;

		my @alter;
		my @changed_columns;
		foreach my $key (keys %fields)
		{
			# Assume if key does not exist in %explain, it doesnt exist in the table
			if(!exists $explain{$key})
			{
				push @alter, 'ALTER TABLE `'.$table.'` ADD '._mysql_fieldspec($fields{$key});
				push @changed_columns, {col=>$key,type=>'ADD'};
			}
			# If key exists in %explain, do a simple eq diff comparrison
			elsif(exists $explain{$key})
			{
				my $a = $explain{$key};
				my $b = $fields{$key};
				my $cnt = 0;
				foreach my $k (keys %$a)
				{
					if($a->{$k} ne $b->{$k})
					{
						# Normalize some nitch cases that are known to be different ...

						# Seems MySQL translates the string \r\n into the actual chr 10 && chr 13
						next if $a->{$k} eq "\r\n" && $b->{$k} eq '\r\n';
						# YES Null from DB and an undef value in $fields is OK
						next if $k eq 'null' &&
							$a->{$k} eq 'YES' && (!defined $b->{$k} || $b->{$k} eq '1');
						# NO Null from DB and a 0 value in $fields is OK
						next if $k eq 'null' &&
							$a->{$k} eq 'NO' && $b->{$k} eq '0';
						# Users of the class sometimes don't uppercase textual "not null" values - so here we do
						next if $k eq 'null' &&
							$a->{$k} eq 'NO' && uc $b->{$k} eq 'NO';
						# Given the type 'integer' (or 'int') to create/alter gives back int(11) in the 'explain ...' stmt
						next if $k eq 'type' &&
							$a->{$k} eq 'int(11)' && ($b->{$k} eq 'integer' || $b->{$k} eq 'int');
						# Translate shorthand for varchar(255) - varchar without modifier is not reconized by mysql,
						# but I allow it here and in the _fieldspec sub and translate it to varchar(255) before mysql sees it
						next if $k eq 'type' &&
							$a->{$k} eq 'varchar(255)' && $b->{$k} eq 'varchar';
						# If type is integer and default is 0 in the db, then here $b->{$k} is '' -- we'll go ahead and allow it
						next if $k eq 'default' &&
							$a->{$k} eq '0' && !$b->{$k} &&
							lc $a->{type} =~ /^int/;
						# Primary Keys that are auto-increment have Null set to NO when seen by 'explain' but the null
						# key is typically undef in the $fields hash - thats okay.
						next if $k eq 'null' &&
							$a->{$k} eq 'NO' && !defined $b->{$k} &&
								$b->{key} eq 'PRI' &&
								$b->{extra} eq 'auto_increment';
						# Even if user specs NULL on a timestamp column, explain returns NOT NULL - ignore and don't try to alter
						next if $k eq 'null' &&
							$a->{$k} ne $b->{$k} &&
							lc $a->{type} eq 'timestamp';
						# timestamp with NULL defaults return CURRENT_TIMESTAMP from mysql - this is valid, just ignore
						# on some systems, it also returns 'on update CURRENT_TIMESTAMP' for key 'extra' - also valid, just ignore
						next if ($k eq 'default' || $k eq 'extra') &&
							uc $a->{$k} =~ 'CURRENT_TIMESTAMP' && !$b->{$k} &&
							lc $a->{type} eq 'timestamp';

						# Multiple keys report oddly, so ignore them...
						next if $k eq 'key' &&
							$a->{$k} eq 'MUL' && !$b->{$k};

						# Given the type 'bit(\d)' to create/alter gives back bit in the 'explain ...' stmt
						next if $k eq 'type' &&
							$a->{$k} =~ /bit\(\d+\)/ && $b->{$k} eq 'bit';

						# Given the type 'smallint(\d)' to create/alter gives back smallint in the 'explain ...' stmt
						next if $k eq 'type' &&
							$a->{$k} =~ /smallint\(\d+\)/ && $b->{$k} eq 'smallint';

						# Given the type 'nvarchar(...)' in the schema gives back varchar(256) in the 'explain ...' stmt
						next if $k eq 'type' &&
							$a->{$k} =~ /varchar\(\d+\)/ && $b->{$k} =~ /varchar\(\d+\)/;

						# Given the type 'money' in the schema gives back double/real in the 'explain ...' stmt
						next if $k eq 'type' &&
							$a->{$k} eq 'double' && $b->{$k} =~ /^(real|money)$/;

						# Given the type 'decimal' in the schema gives back numeric in the 'explain ...' stmt
						next if $k eq 'type' &&
							$a->{$k} =~ /^decimal\(/ && $b->{$k} =~ /^(decimal|numeric)$/;

						# varchar(256) from database == uniqueidentifier (schema)
						next if $k eq 'type' &&
							$a->{$k} eq 'varchar(256)' && $b->{$k} eq 'uniqueidentifier';

						# bigint(...) from database == bigint (schema)
						next if $k eq 'type' &&
							$a->{$k} =~ /^bigint\(/ && $b->{$k} eq 'bigint';

						# tinyint(...) from database == tinyint (schema)
						next if $k eq 'type' &&
							$a->{$k} =~ /^tinyint\(/ && $b->{$k} eq 'tinyint';

						# varchar(256) from database == varchar(-1) (schema)
						next if $k eq 'type' &&
							$a->{$k} eq 'varchar(256)' && $b->{$k} eq 'varchar(-1)';

						# varchar(255) from database == varchar(-1) (schema)
						next if $k eq 'type' &&
							$a->{$k} eq 'varchar(255)' && $b->{$k} eq 'varchar(-1)';

						# varchar(255) from database == nvarchar(-1) (schema)
						next if $k eq 'type' &&
							$a->{$k} eq 'varchar(255)' && $b->{$k} eq 'nvarchar(-1)';

						# datetime from database == smalldatetime (schema)
						next if $k eq 'type' &&
							$a->{$k} eq 'datetime' && $b->{$k} eq 'smalldatetime';

						# longtext from database == xml(-1) (schema)
						next if $k eq 'type' &&
							$a->{$k} eq 'longtext' && $b->{$k} eq 'xml(-1)';

						# blob from database == image(...) (schema)
						next if $k eq 'type' &&
							$a->{$k} eq 'blob' && $b->{$k} =~ /^image\(\d+/;

						# char(...) from database == nchar(...) (schema)
						next if $k eq 'type' &&
							$a->{$k} =~ /^char\(/ && $b->{$k} =~ /^nchar\(/;

						# Handle enums that have newlines and spaces in their schema definitions in perl
						# because MySQL stores them as a single line
						if($k eq 'type' && $b->{$k} =~ /enum/ && $b->{$k} =~ /\n/)
						{
							my $tmp = $b->{$k};
							$tmp =~ s/\s*\n\s*//g;
							#print "tmp:$tmp\n";
							#print "  a:$a->{$k}\n";
							next if $a->{$k} eq $tmp;
						}

						print STDERR "Debug: k=$k, a=$a->{$k}, b=$b->{$k}, type=$a->{type}\n";
						$cnt ++;
					}
				}

				if($cnt > 0)
				{
					push @alter, 'ALTER TABLE `'.$table.'` CHANGE `'.$key.'` ' . _mysql_fieldspec($fields{$key}, { ignore => [qw/key/] } );
					push @changed_columns, {col=>$key,type=>'CHANGE'};
				}
			}
		}

		foreach my $key (keys %explain)
		{
			if(!exists $fields{$key})
			{
				# Decide if this is safe
				if($ALLOW_DROP) {
					push @alter, 'ALTER TABLE `'.$table.'` DROP `'.$key.'`';
					push @changed_columns, {col=>$key,type=>'DROP'};
				} else {
					print STDERR " ***** Possible drop needed, but not dropping to preserve data: '$table.$key'\n";
				}
			}
		}


		if(@alter)
		{
			## Run before_alter sub
			$opts->{before_alter}->($dbh,\@changed_columns) if ref $opts->{before_alter} eq 'CODE';

			my $sql = join ";\n", @alter;
			print STDERR "Debug: [$db] Alter table: \n$sql\n";

			push @sql, $sql;

			#my @ok = grep { !/\sDROP\s/ } @alter;
			my @ok = @alter; #grep { !/\sDROP\s/ } @alter;
			foreach my $stmt (@ok)
			{
				eval
				{
					$dbh->do($stmt) unless $dry_run;
				};
				if($@)
				{
					print STDERR "Error: $@ while executing '$stmt'\n";
					die "$@ while executing '$stmt'";
				}
			}

			## Run after_alter sub
			$opts->{after_alter}->($dbh,\@changed_columns) if ref $opts->{after_alter} eq 'CODE';
		}

	}
	# Assume table DOES NOT exist - create
	else
	{
		# Compose the SQL statement and send to the server
		my @buff = 'CREATE TABLE `'.$table.'` (';
		push @buff, join (", ", map { _mysql_fieldspec($_) } @$fields);
		push @buff, ') character set utf8mb4';
		my $sql = join '',@buff;

		print STDERR "Debug: $sql\n";
		my $sth = $dbh->prepare($sql);

		push @sql, $sql;

		$sth->execute unless $dry_run;

		# Run the post-create code or insertion array
		my $after_create = $opts->{after_create};
		if(ref $after_create eq 'CODE')
		{
			$after_create->($dbh);
		}
		elsif(ref $after_create eq 'ARRAY')
		{
			# If given an array ref, the rows are also expected to be array refs
			# NOTE: The rows must have exactly the number of columns that are in the DB
			# - and in the same order as the $fields hash
			my $cols = scalar @$fields;
			my @buff = ('?') x $cols;
			my $sql = 'INSERT INTO `'.$table.'` VALUES ('.join(',',@buff).')';
			print STDERR "Debug: insert sql: $sql\n";

			if(!$dry_run)
			{
				my $sth = $dbh->prepare($sql);
				$sth->execute(@$_) foreach @$after_create;
				$sth->finish;
			}
		}
	}

	$opts->{indexes} = {} if !$opts->{indexes};

	if(ref $opts->{indexes} eq 'HASH')
	{
		# Add a default index on the isDeleted column
		$opts->{indexes}->{'isDeleted'} = ['isDeleted'];
		# Add a default index on the account and isDeleted columns
		# $opts->{indexes}->{'account_isDeleted'} = ['account', 'isDeleted'];

		# Load existing indexes from database
		my $sth_existing_idx = $dbh->prepare('show indexes from `'.$table.'`');

		my $old_fatal = $SIG{__DIE__};
		$SIG{__DIE__} = sub{return};
		eval '$sth_existing_idx->execute();';
		$SIG{__DIE__} = $old_fatal;
		if($@) {
			warn "Problem while trying to discover existing indexes: '$@'" unless $@ =~ /Table .* doesn't exist/ && $dry_run;
		}

		my %hash;
		if(!$@) {
			while(my $ref = $sth_existing_idx->fetchrow_hashref)
			{
				$hash{$ref->{key_name}} ||= {};
				$hash{$ref->{key_name}}->{$ref->{column_name}} = $ref;
			}
		}

		# Compare indexes in %opts with the database indexes
		my %idx = %{ $opts->{indexes} || {} };
		foreach my $key_name (keys %idx)
		{
			my $diff = 0;
			my $drop = 0;
			my $db_data = $hash{$key_name};

			# If index does exists in DB, compare and flag if different
			if($db_data)
			{
				my @cols = @{ $idx{$key_name} || [] };
				foreach my $col (@cols)
				{
					$diff = 1 if !$db_data->{$col};
				}
				$drop = 1 if $diff;

				# TODO: Compare diff the other direction: DB has cols that @cols does not have......
			}
			# Index does NOT exist, flag for creation
			else
			{
				$diff = 1;
			}

			# Drop existing index if DB differs from %opts
			if($drop)
			{
				my $sql = 'drop index `'.$key_name.'` on `'.$table.'`';
				print "Debug: Index '$key_name' changed, deleting and recreating. Delete SQL: $sql\n";
				push @sql, $sql;

				$dbh->do($sql) unless $dry_run;
			}

			# Create index if different or if does not exist
			if($diff)
			{
				my @cols = @{ $idx{$key_name} || [] };
				my $sql = 'create index `'.$key_name.'` on `'.$table.'`(';
				$sql .= join(',', map { '`'.$_.'`' . ($fields{$_}->{type} =~ /text/ ? '(255)' : '') } @cols);
				$sql .= ')';

				print "Debug: (re)Creating index '$key_name': $sql\n";
				push @sql, $sql;
				$dbh->do($sql) unless $dry_run;
			}
		}

		# Compare indexes in %opts with ones in DB and delete from DB any not in %opts
		foreach my $key_name (keys %hash)
		{
			next if $key_name eq 'PRIMARY';
			if(!$opts->{indexes}->{$key_name})
			{
				my $sql = 'drop index `'.$key_name.'` on `'.$table.'`';
				print "Debug: Index '$key_name' removed: $sql\n";
				push @sql, $sql;
				$dbh->do($sql) unless $dry_run;
			}
		}
	}
	elsif($opts->{indexes})
	{
		warn "I don't know how to handle '$opts->{indexes}' for {indexes} option\n";
	}

	push @mysql_schema_sql_debug_output, @sql ? ("<h3>Table: $table</h3>", @sql) : ();
}

# Function: _mysql_fieldspec
# PRIVATE
# Translates an 'explain TABLE' output row into a SQL statement fragment that can be used to create or alter that field
sub _mysql_fieldspec
{
	local $_ = shift;
	my $opts = shift || { ignore => [] };
	my %ignore = map { $_ => 1 } @{$opts->{ignore} || [] };
	$_->{null} = uc $_->{null} if defined $_->{null};
	$_->{type} = 'varchar(255)' if lc $_->{type} eq 'varchar' || $_->{type} eq 'varchar(-1)' || $_->{type} eq 'nvarchar(-1)';
	$_->{type} = 'real' if $_->{type} eq 'money';
	$_->{type} = 'datetime' if $_->{type} eq 'smalldatetime';
	$_->{type} = 'varchar(256)' if $_->{type} eq 'uniqueidentifier';
	$_->{type} = 'longtext' if $_->{type} eq 'xml(-1)';
	$_->{type} = 'blob' if $_->{type} =~ /image\(\d+\)/;

	my $sql = "`$_->{field}` $_->{type}".
		($_->{null} eq 'NO' || $_->{null} eq '0' ? ' NOT NULL' : '').
		(!$ignore{key} &&
		 $_->{key}  eq 'PRI' ? ' PRIMARY KEY' .
			($_->{extra} ? ' '.$_->{extra} : '') :
		$_->{key}  eq 'UNI' ? ' UNIQUE' : '' ## TODO: Support other varients of Key if needed
		).
		(defined $_->{default} ? (
			$_->{default} eq 'CURRENT_TIMESTAMP' ? '' :
			$_->{default} eq '' && $_->{type}=~/^int/ ? ' DEFAULT 0' :
			$_->{default} ne 'NULL' ? ' DEFAULT "'.$_->{default}.'"' :
			'' )
		: '');
		#$_->{Extra};

	# print STDERR "fieldspec: " . $sql, "\n";
	return $sql;

}

sub upload_match_ratio_function {
	# my $dbh = shift;
	# 'localhost', $DB_NAME, 'root', $PASSWORD
	my ($host, $db, $user, $pass) = @_;

	my $tmp = "/tmp/f$$.sql";
	open(TMP, ">$tmp") || die "Cannot write $tmp: $!";

	print TMP q{
		DELIMITER //

		DROP FUNCTION  IF EXISTS `match_ratio` //

		CREATE FUNCTION `match_ratio` ( s1 text, s2 text, s3 text ) RETURNS int(11)
			DETERMINISTIC
		BEGIN
			DECLARE s1_len, s2_len, s3_len, max_len INT;
			DECLARE s3_tmp text;

			SET s1_len = LENGTH(s1),
				s2_len = LENGTH(s2);
			IF s1_len > s2_len THEN
				SET max_len = s1_len;
			ELSE
				SET max_len = s2_len;
			END IF;

			if lower(s1) like concat('%',lower(s2),'%') then
				return round((1 - (abs(s1_len - s2_len) / max_len)) * 100);
			else
				set s3_tmp = replace(s3, '%', '');
				set s3_len = length(s3_tmp);


				IF s1_len > s3_len THEN
					SET max_len = s1_len;
				ELSE
					SET max_len = s3_len;
				END IF;

				if lower(s1) like concat('%',lower(s3),'%') then
					/*round(abs(s1_len - s3len) / max_len * .5 * 100);*/
					return round((1 - (abs(s1_len - s3_len) / max_len)) * .5 * 100);
				else

					return 0;
				end if;
			end if;

		END //
		DELIMITER ;
	};

	# Cannot insert a function via the socket connection in $dbh,
	# so we have to resort to the command line
	# The fancy $(which mysql) is needed on mac for some weird path resolution reason
	my $cmd = "\$(which mysql) -u ${user} --password=${pass} -h ${host} -D ${db} < $tmp";
	print STDERR "Uploading match_ratio() function: $cmd\n";
	system($cmd);

	unlink($tmp);
}

sub upload_id_trigger {
	my $dbh = shift; # for checking for trigger exists
	# 'localhost', $DB_NAME, 'root', $PASSWORD
	my ($host, $db, $user, $pass, $table) = @_;

	my $trigger_name = "before_insert_${table}_set_id";

	# If trigger doesn't exist, errors are thrown, hence the eval
	my $found = 0;
	eval {
		my $check_sth = $dbh->prepare_cached('show create trigger '. $trigger_name);
		$check_sth->execute;
		$found = $check_sth->rows;
	};
	return if $found;

	my $tmp = "/tmp/f$$.sql";
	open(TMP, ">$tmp") || die "Cannot write $tmp: $!";

	print TMP qq{
		DROP TRIGGER IF EXISTS ${trigger_name};
		DELIMITER ;;
		CREATE TRIGGER ${trigger_name}
		BEFORE INSERT ON ${table}
			FOR EACH ROW
			BEGIN
				IF (new.id IS NULL or new.id = '') THEN
					SET new.id = uuid();
				END IF;
			END
		;;
		DELIMITER ;
	};

	# Cannot insert a function via the socket connection in $dbh,
	# so we have to resort to the command line
	my $cmd = "mysql -u ${user} --password=${pass} -h ${host} -D ${db} < $tmp";
	print STDERR "Uploading trigger '$trigger_name': $cmd\n";
	system($cmd);

	unlink($tmp);
}
